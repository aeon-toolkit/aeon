# File: aeon/transformations/series/smoothing/tests/test_lowess.py
"""Unit tests for LOWESS (Numba-optimised) smoother."""

import numpy as np
import pytest

from aeon.transformations.series.smoothing._lowess import (
    LOWESS,
    _bisquare,
    _calc_resid_weights,
    _fit_one_point_regular,
    _interpolate_segment,
    _lowess_1d,
    _lowess_2d,
    _median_1d,
    _tricube_from_distnorm,
)

# Tiny numerical tolerance for float noise (esp. with numba fastmath)
_ATOL_TINY = 1e-12
_RTOL_TINY = 0.0


X = np.array(
    [
        [
            -1.42382504,
            1.26372846,
            -0.87066174,
            -0.25917323,
            -0.07534331,
            -0.74088465,
            -1.3677927,
            0.6488928,
            0.36105811,
            -1.95286306,
            2.34740965,
            0.96849691,
            -0.75938718,
            0.90219827,
            -0.46695317,
            -0.06068952,
            0.78884434,
            -1.25666813,
            0.57585751,
            1.39897899,
            1.32229806,
            -0.29969852,
            0.90291934,
            -1.62158273,
            -0.15818926,
        ]
    ],
    dtype=np.float64,
)

statsmodels = np.array(
    [
        [
            -0.48340952,
            -0.36907487,
            -0.2396061,
            -0.2646435,
            -0.50199931,
            -0.54372974,
            -0.38772037,
            -0.34132169,
            -0.13263726,
            0.29553049,
            0.38175872,
            0.58009858,
            0.44973045,
            0.03545376,
            0.08462599,
            0.0296369,
            -0.10036147,
            0.12297534,
            0.41305537,
            0.73261516,
            0.80945658,
            0.46219153,
            -0.03191809,
            -0.39956581,
            -0.7731989,
        ]
    ],
    dtype=np.float64,
)


def test_against_statsmodels():
    """Compare against a reference generated by statsmodels LOWESS.

    The expected output (``statsmodels``) was generated locally using
    ``statsmodels.nonparametric.smoothers_lowess.lowess`` with:

    - frac=0.3
    - it=0
    - delta=0.0
    - is_sorted=True
    - return_sorted=False

    Statsmodels is not a test dependency in CI, so the reference values are
    hard-coded in this test. Generated with statsmodels version 0.14.5.
    """
    trf = LOWESS(frac=0.3, it=0, delta=0.0)
    res = trf.fit_transform(X)
    np.testing.assert_allclose(statsmodels, res, rtol=0.0, atol=5e-5)


def test_tricube_endpoints():
    """Tricube kernel should map 0 -> 1 and 1 -> 0."""
    assert _tricube_from_distnorm(0.0) == 1.0
    assert _tricube_from_distnorm(1.0) == 0.0


def test_tricube_monotone_decreasing():
    """Tricube kernel should be non-increasing on [0, 1] and stay in [0, 1]."""
    dn = np.linspace(0.0, 1.0, 11)
    w = np.array([_tricube_from_distnorm(float(d)) for d in dn])
    assert np.all(w[:-1] >= w[1:])
    assert w.min() >= 0.0
    assert w.max() <= 1.0


def test_bisquare_endpoints():
    """Bisquare weight should map 0 -> 1 and 1 -> 0."""
    assert _bisquare(0.0) == 1.0
    assert _bisquare(1.0) == 0.0


def test_bisquare_monotone_decreasing():
    """Bisquare weight should be non-increasing on [0, 1] and stay in [0, 1]."""
    z = np.linspace(0.0, 1.0, 11)
    w = np.array([_bisquare(float(v)) for v in z])
    assert np.all(w[:-1] >= w[1:])
    assert w.min() >= 0.0
    assert w.max() <= 1.0


@pytest.mark.parametrize("n", [1, 2, 5, 6, 11, 12])
def test_median_1d_matches_numpy(n):
    """Median helper should match numpy.median for small 1D arrays."""
    rng = np.random.RandomState(42)
    a = rng.standard_normal(n).astype(np.float64)
    got = _median_1d(a)
    exp = float(np.median(a))
    np.testing.assert_allclose(got, exp, rtol=0.0, atol=0.0)


def test_calc_resid_weights_all_ones_for_perfect_fit():
    """Residual weights should be all ones when y_fit == y (zero residuals)."""
    y = np.array([1.0, 2.0, 3.0, 4.0], dtype=np.float64)
    y_fit = y.copy()
    w = _calc_resid_weights(y, y_fit)
    np.testing.assert_allclose(w, np.ones_like(y), rtol=_RTOL_TINY, atol=_ATOL_TINY)


def test_calc_resid_weights_downweights_outlier():
    """Residual weights should downweight a large residual relative to others."""
    y = np.zeros(9, dtype=np.float64)
    y_fit = y.copy()
    y_fit[4] = 10.0  # large residual at centre
    w = _calc_resid_weights(y, y_fit)
    assert w[4] < 1.0
    assert np.all(w[np.arange(len(w)) != 4] >= w[4])


def test_interpolate_segment_linear():
    """Interpolation should fill interior points with a straight line."""
    y_fit = np.zeros(6, dtype=np.float64)
    y_fit[1] = 2.0
    y_fit[4] = 8.0

    _interpolate_segment(y_fit, 1, 4)

    np.testing.assert_allclose(y_fit[2], 4.0, rtol=0.0, atol=0.0)
    np.testing.assert_allclose(y_fit[3], 6.0, rtol=0.0, atol=0.0)


@pytest.mark.parametrize("n", [1, 2, 5, 10])
def test_fit_one_point_regular_constant_returns_constant(n):
    """Fitting one point on a constant series should return that constant."""
    y = np.full(n, 3.0, dtype=np.float64)
    resid_w = np.ones(n, dtype=np.float64)
    k = min(max(2, n), n)

    for i in range(n):
        got = _fit_one_point_regular(y, resid_w, i, k)
        np.testing.assert_allclose(got, 3.0, rtol=_RTOL_TINY, atol=_ATOL_TINY)


@pytest.mark.parametrize("frac", [0.0, 0.1, 0.3, 1.0])
@pytest.mark.parametrize("it", [0, 2])
@pytest.mark.parametrize("delta", [0.0, 2.0])
def test_lowess_1d_constant_is_fixed_point(frac, it, delta):
    """LOWESS should leave a constant series unchanged (up to tiny float noise)."""
    y = np.full(25, 7.5, dtype=np.float64)
    y_fit = _lowess_1d(y, float(frac), int(it), float(delta))
    np.testing.assert_allclose(y_fit, y, rtol=_RTOL_TINY, atol=_ATOL_TINY)


@pytest.mark.parametrize("frac", [0.1, 0.3, 1.0])
@pytest.mark.parametrize("it", [0, 3])
@pytest.mark.parametrize("delta", [0.0, 3.0])
def test_lowess_1d_linear_is_fixed_point(frac, it, delta):
    """LOWESS should reproduce an exactly linear signal on a regular grid."""
    t = np.arange(50, dtype=np.float64)
    y = 1.25 + 2.0 * t
    y_fit = _lowess_1d(y, float(frac), int(it), float(delta))
    np.testing.assert_allclose(y_fit, y, rtol=1e-10, atol=1e-10)


def test_lowess_1d_n_equals_1_returns_input():
    """LOWESS should return the input when n_timepoints == 1."""
    y = np.array([3.14], dtype=np.float64)
    y_fit = _lowess_1d(y, 0.3, 0, 0.0)
    np.testing.assert_allclose(y_fit, y, rtol=_RTOL_TINY, atol=_ATOL_TINY)


def test_lowess_2d_matches_channelwise_lowess_1d():
    """2D wrapper should equal applying 1D LOWESS independently per channel."""
    t = np.arange(30, dtype=np.float64)
    ch0 = np.full_like(t, 2.0, dtype=np.float64)
    ch1 = 3.0 - 0.5 * t
    X = np.vstack([ch0, ch1])

    frac, it, delta = 0.3, 0, 0.0
    got = _lowess_2d(X, frac, it, delta)

    exp0 = _lowess_1d(ch0, frac, it, delta)
    exp1 = _lowess_1d(ch1, frac, it, delta)
    exp = np.vstack([exp0, exp1])

    assert got.shape == X.shape
    assert got.dtype == np.float64
    np.testing.assert_allclose(got, exp, rtol=_RTOL_TINY, atol=_ATOL_TINY)


def test_transformer_output_shape_and_dtype():
    """Transformer should preserve shape, return float64, and produce finite output."""
    rng = np.random.RandomState(0)
    X = rng.standard_normal((2, 40)).astype(np.float32)

    trf = LOWESS(frac=0.2, it=0, delta=0.0)
    Xt = trf.fit_transform(X)

    assert Xt.shape == X.shape
    assert Xt.dtype == np.float64
    assert np.isfinite(Xt).all()


@pytest.mark.parametrize(
    "params",
    [
        {"frac": -0.1, "it": 0, "delta": 0.0},
        {"frac": 1.1, "it": 0, "delta": 0.0},
        {"frac": 0.3, "it": -1, "delta": 0.0},
        {"frac": 0.3, "it": 0, "delta": -0.5},
    ],
)
def test_transformer_parameter_validation(params):
    """Invalid (frac, it, delta) parameters should raise ValueError."""
    X = np.ones((1, 10), dtype=np.float64)
    trf = LOWESS(**params)
    with pytest.raises(ValueError):
        trf.fit_transform(X)
